# YourSQL

本组程序基于 D 组代码继续开发。

下面所有在 D 组第一阶段中已经存在的功能、bug、feature 均用 * 标注。

## 结构设计

*数据库系统的所有资源均置于 `OOPD` 名称空间中。

### *`Controller`

接收并执行 SQL 语句。

### `Session`

也可以接收并执行 SQL 语句。代码由 `Controller` 改造而来，将在后面详细说明。

### `Table`

数据表。定义表的结构并存储数据，*采用 B+ 树。

### *`DataBase`

数据库。包含数据表的集合。

### *`BPTree`, *`BPTreeNode`

B+ 树及 B+ 树的结点。设计成模板类以方便类型复用。

## 第二阶段新增内容

### 基础需求 (25%)

* [x] (5%) 兼容第一阶段代码（兼容 main.cpp、`OOPDB` 类和`Controller` 类）
* [x] (5%) `SELECT INTO` 保存数据库输出到文件；`LOAD DATA` 从文件加载数据表
* [ ] (5%) `COUNT()` 函数
* [ ] (5%) `GROUP BY` 分组子句
* [ ] (5%) `ORDER BY` 排序子句

### 拓展需求 (35%)

* [ ] (10%) 更多数字函数
* [x] (15%) 远程访问支持
* [ ] (10%) 存档/读档功能，且每次操作均可保存文件

## 任务分工

### 第一阶段（simple-db）

* 数据类型系统 `data_t`
* 数据库结构设计
* 外壳代码

### 第二阶段（YourSQL）

#### 基础需求

* 文件读写
* 数字函数及查询分组
* 排序 `ORDER BY` 子句

#### 拓展需求

* 数据存档（每次修改数据的操作均会保存记录，但未优化复杂度）
* 数字函数（`COUNT`、`SUM` 求和、`MIN` 最小值、`MAX` 最大值、`AVG` 平均值、`STDDEV` 标准差）
* 网络访问 + 并发处理

### 其他任务

* 替换 SQL 语句解释器
* 消除 magic number（第一阶段期间的代码存在用 0x3f3f3f 表示 NULL 的现象）

## 对一些特殊的/不甚合理的设计/编码的解释

这些几乎都是 D 组第一阶段代码的遗留问题，第二阶段限于时间或为了避免大幅修改底层结构而只能将就。

## 没有修改 `Controller` 而是另外写了 `Session` 类

1. 前后端分离。`Controller` 是外壳组件，在大作业中视为「测试代码」；
2. `Controller` 对 SQL 语句的处理很差，到处都是空格和大小写判断；
3. D 组代码中将 `Controller` 和 `DataBase` 打包放到了 `OOPDB` 类中，破坏了前后端分离原则；
4. 避免过度修改 `Controller` 类造成与第一阶段 D 组的 main.cpp 和 `OOPDB` 类不兼容。

## 到处都是数据类型判断，极度混乱

这个真的是 D 组第一阶段代码的问题……

每条记录（`struct Data`）包含三个 `std::vector`，分别是 `int`、`double`、`std::string`；类似地，表中的 B+ 树也区分三种类型；在外层几乎所有操作上，都要区分三种数据类型。这种结构导致我们很难增加 `DATE` 或 `TIME` 之类新的数据类型。

如果我们用统一的数据结构表示形式（例如本组第一阶段使用的、大作业展示时提到的 `data_t` 指针+继承结构设计），那么将不得不大幅修改底层结构，甚至废掉 B+ 树设计（虽然也没有实际用上）；同时，对代码底层进行大幅度重构的做法尽管可以保持接口兼容，但却违背了大作业「体验代码再开发的过程」的目的（大作业 PPT 第 3 页）。

而至于我们为什么选择了这组代码做第二阶段开发，只是因为我们不想让第二阶段分数打八折+我们认为这个代码在四组中算是相对比较好的……

## 命名风格杂糅

这是有意为之。D 组第一阶段的代码大量使用首字母**大写**的驼峰命名法；第二阶段的新增内容几乎都（除非是基于原来代码复制、修改的部分）使用了首字母**小写**的驼峰命名法。可以对区别两阶段代码提供一定帮助。
